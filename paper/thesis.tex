\documentclass[
	11pt, 
	a4paper, 
	oneside,  
	final, 
]{report}

\usepackage{graphicx}
\usepackage{algorithm, algorithmicx, algpseudocode}
\usepackage{amsmath}


\title{Hessian Optimization for Newton's Method}
\author{Hantao Hui}


\begin{document}
\maketitle
\newpage
\tableofcontents

\chapter{INTRODUCTION}
\section{Motivation}
As recent research has showed that ..
\section{Structure}
The first chapter is goting to talk about somehting !
\chapter{RELATED WORK}

This is a reference~\cite{Foley:1990}.

\section{Related Work 1}

% \begin{figure}[tb]
% 	\centering
% 	\includegraphics[width=0.5\linewidth]{images/image}
% 	\caption{\label{fig:image} This is an image.
% 	}
% \end{figure}

% \begin{table}[tb]
% 	{
% 		\centering
% 		\begin{tabular}{|c|c|c|c|}
% 			\hline
% 			      & col 1 & col 2 & col 3 \\
% 			\hline	
% 			row 1 & 1     & 2     & 3     \\
% 			row 2 & 4     & 5     & 6     \\
% 			row 3 & 7     & 8     & 9     \\
% 			\hline
% 		\end{tabular}
% 		\caption{\label{tab:example} This is a table.}
% 	}
% \end{table}


% Figure~\ref{fig:image} shows an example of an image.
% Table~\ref{tab:example} shows an example of a table.


\chapter{TECHNICAL BACKGROUND}
\section{FEM Simulation}
\section{Backward Euler}
\section{Minimization Problem}
\chapter{FAST HESSIAN ESTIMATION}
In this chapter, We are going to talk about the implementation details of the fast hessian estimation algorithm. Basically, it includes two parts of the algorithm. The first part is, how we iteratively update the global hessian matrix. The second part is, for each component level, e.g. stiffness matrix, collision hessian matrix, how to optimize furthermore.
\section{Global Hessian}

Gast(here) has showed that any local minimum to the equation(here) is the solution to the original nonlinear equation(number here), in the meanwhile, global minimum of equation always exists. In order to find the local minimum, Newton's method has been used. After several Newton steps, it reached to the point, where $\nabla E = 0$. 

Normally, we can easily find out that, a deformable object can have different degress of deformation inside its body. For example, imagine there is a bunny sitting on the ground, then we pull one of its ears up. Though the ear being pulled will have large deformation, but the main body will remain relatively static, with very small deformation. In another word, some vertices will have large displacement, while the rest of them have samll displacements. Similarly, we believe that, during the Newton steps, the vertices, which have small displacements, will make the corresponding gradient part reach to zero faster, while the other part of vertices, will make the corresponding gradient part reach to zero slower.

In order to utilize this information, we think that, since small displacements vertices will converge faster, which means we can low accuracy hessian matrix. In this paper, we used hessia matrix from previous step. An overview of algorithm can be found as pseudo-code in Algorithm \ref{algorithm:overview}.
\begin{algorithm}
	\caption{Algorithm}
	\label{algorithm:overview}
	\begin{algorithmic}[1]
		\Procedure{Gradient}{}
		\State calculate global gradient  $\nabla E$
		\For{\texttt{($i$, $v$) in $\nabla E$.enumerate() }}
		\If{abs($v$) $ \leq \epsilon$}
		\State $UpdateList$.push($i$)
		\EndIf 
		\EndFor
		\State return $\nabla E$
		\EndProcedure\\
		
		\Procedure{Hessian}{}
		\State calculate inertia hessian  $H_{in}$ with $UpdateList$
		\State calculate elastic hessian  $H_{el}$ with $UpdateList$
		\State calculate collision hessian  $H_{co}$ with $UpdateList$
		\State return global hessia as $H_{in}+H_{el}+H_{co}$
		\EndProcedure
		
	\end{algorithmic}
\end{algorithm}

And we will discuss more details with how to calculate hessian of each part with $UpdateList$ in the next section.




\section{Component-wise Hessian}
\subsection{Inertia}
From the formula(number), we can easily see that inertia hessian matrix is the lumped mass matrix. And in this paper, mass matrix does not change in every Newton's steps. So $UpdateList$ has no use here.
\subsection{Elastic}
Elastic hessian matrix is the most difficult part to solve, because the number of primitives is usually quite large. With the help of $UpdateList$, it can help us to recude some calculations of unnecessary hessians. We can simply extract all the vertices from $UpdateList$, then find all the primitives, which are connected with those vertices. Then solve the hessian matrix with those primitives only.

Even thoug, there are still plenty of primitives left need to be solved. We need to eliminate more primitives. In this paper, we used St. Venant-Kirchhoff energy model as elastic energy, which is defined as 
$$
	\Psi = \mu E:E + \frac{\lambda}{2} tr^{2}(E) 
$$
, where $E$ are the Green strain tensor, which is defined as 
$$
	E = \frac{1}{2}(F^{T}F -I)
$$ and $\mu,\lambda$ are Lam√© coefficients which define the material properties.

Now we consider everytime we update the vertices coordiantes vector $X$, no matter it is between Newton's step, or moves to the next time step, we can always treat it with $X_{new} = X_{old} + \Delta X$. When move to the next time step, $\Delta X$ can be considered as the difference between the last time step $X_{old}$ and the initial guess of the new time step $X_{new_{initial}}$. If $ \Delta X$ is small enough, then which means, the elastic energy won't change much, so is the hessian matrix. So, we can calculate the $F_{t+1}$ and $F_{t}$, and if  $F_{t+1} \cdot F_{t}^{-1}$ is close to a rotation matrix, then it means $ F_{t+1}^{T} F_{t+1} = F_{t}^{T} F_{t}$, so it has no effect on elastic energy.


Now consider a 2d case, we can simply write $F$ as
$$
	F_{t} = \begin{pmatrix}
		a & b \\ 
		c & d
	\end{pmatrix}
	\text{ and }
	F_{t}^{-1} = \frac{1}{ad-bc}\begin{pmatrix}
		d  & -b \\ 
		-c & a
	\end{pmatrix}
$$
then we write $F_{t+1}$ as
$$
	F_{t+1} = \begin{pmatrix}
		a+m & b+n \\ 
		c+p & d+q
	\end{pmatrix}
$$
then
$$
	F_{t+1} \times F_{t}^{-1} = \frac{1}{ad-bc}
	\begin{pmatrix}
		ad-bc-cn+dm & an-bm       \\ 
		dp-cq       & ad+aq-bc-bp
	\end{pmatrix}
$$
In order to make this matrix close to a rotation matrix, it's equivalent to make its determinant equals to 1, which is 
\begin{align*}
	\frac{a(d+q)-b(c+p)-cn+dm +mq-np}{ad-bc} = 1 
	\\
	aq-bp-cn+dm+mq-np = 0
\end{align*}

Now, we can simply calculate the $aq-bp-cn+dm+mq-np$, when it is smaller than tolerance $\epsilon$, then simply fetch the elastic data from previous time step.

A detailed algorithm can be found as pseudo-code in Algorithm \ref{algorithm:elastic}.

\begin{algorithm}
	\caption{Algorithm}
	\label{algorithm:elastic}
	\begin{algorithmic}[1]
		\Procedure{Elastic Hessian}{}
		\State Find all the vertices correspond to the $UpdateList$
		\State Find all the primitives which connected with these vertices
		\State Denote these primitives as $PrimList$
		\For{\texttt{$prim$ in $AllPrimList$ }}
		\If{$prim$ in $PrimList$}
		\State fectch hessian from last time step
		\Else
		\If{$aq-bp-cn+dm+mq-np \leq \epsilon$ }
		\State fectch hessian from last time step
		\Else
		\State solve hessian matrix $H_{p}$ of this $prim$
		\EndIf
		\EndIf
		\State update the hessian list of current time step
		\State put $H_{p}$ in the correct position of global elastic hessian matrix $H_{el}$
		\EndFor
		\State return $H_{el}$
		\EndProcedure
		
	\end{algorithmic}
\end{algorithm}

\subsection{Collision}



In order to make collision energy more general, we used the formula from Gast. The energy is defined as
$$
	\Psi_{bp} = 
	\begin{cases}
		0,               & \text{if } \phi_b(x_p) \geq 0 \\
		k\phi_b(x_p)^3 , & \text{otherwise}
	\end{cases}
$$

Mark: this is wrong, hessian could be non diagonal matrix, because $\phi$ is unknown. 

From the formula, we can easily see that, hessian matrix is a diagonal matrix. And $H_{co}[i,i]$ is non-zero if and only if gradient $\nabla E [i]$ is non-zero. So we can easily keep an record of non-zero entries while solving the gradient. 




\chapter{Optimization}
\section{Sparse Matrix and Linear Solver}


In general, hessian matrix used in FEM simulation is a sparse matrix. More precisely, the structure of the matrix is decided by the connectivity of the mesh structure.

From above, We have shown that a global hessian can be decomposed as three parts, mass matrix, stiffness matrix

For example, given a triangle mesh, we pick one vertex $A$ from the mesh, use $X_A$, $Y_A$ to denote the coordiantes of $A$ correspondingly, 

\chapter{SIMULATION RESULT}
\section{Scenario Setup}
\section{Some Analysis}
\chapter{CONCLUSION AND FUTURE WORK}


\bibliographystyle{alpha}
\bibliography{references}

\end{document}
